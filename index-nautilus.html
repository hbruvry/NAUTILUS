<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Nautilus</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script type="module">
			import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';
			import { MathUtils } from 'https://unpkg.com/three@0.121.1/build/three.module.js';
			import Stats from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/stats.module.js';
			import { GUI } from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/dat.gui.module.js';
			import { VertexNormalsHelper } from 'https://unpkg.com/three@0.121.1/examples/jsm/helpers/VertexNormalsHelper.js';
			import { EXRLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/EXRLoader.js';

			let container, stats;
			let camera, controls, scene, renderer;
			let hemiLight, spotLight;
			let debug = false;

			let spiralLine, spiralHelper;
			let spiralAngleStep = Math.PI / 30;
			let spiralSubdivision = 0;
			let spiralSubdivisionMax = 1024;

			let supershapesLine = [];
			let supershapesHelper = [];
			let supershapeAngleStep = Math.PI / 60;
			let supershapeSubdivision = 0;
			let supershapeSubdivisionMax = 1024;

			let nautilus, nautilusHelper;

			const params = {
				shapeRevolution: 6,
				shapeAA: 1,
				shapeAB: 1,
				shapeAM: 0,
				shapeAN1: 1,
				shapeAN2: 1,
				shapeAN3: 1,
				shapeBA: 1,
				shapeBB: 1,
				shapeBM: 0,
				shapeBN1: 1,
				shapeBN2: 1,
				shapeBN3: 1,
				spiralA: 1.0,
				spiralB: 0.128
			};

			init();
			animate();

			function setNautilusAttributes()
			{
				let positions, normals;
				let vertex, normal;
				let supershapePositions, supershapeNormals;
				let index;

				positions = nautilus.geometry.attributes.position.array;
				normals = nautilus.geometry.attributes.normal.array;
				for ( let i = 0; i < spiralSubdivision; i ++ )
				{
					index = i * ( supershapeSubdivision + 1 ) * 3;
					supershapePositions = supershapesLine[ i ].geometry.attributes.position.array;
					supershapeNormals = supershapesLine[ i ].geometry.attributes.normal.array;
					for ( let j = 0, k = 0; j < supershapeSubdivision; j ++, k += 3 )
					{
						supershapesLine[ i ].updateMatrixWorld();
						vertex = new THREE.Vector3( supershapePositions[ k ], supershapePositions[ k + 1 ], supershapePositions[ k + 2 ] );
						vertex.applyMatrix4( supershapesLine[ i ].matrixWorld );
						positions[ index + k ] = vertex.x;
						positions[ index + k + 1 ] = vertex.y;
						positions[ index + k + 2 ] = vertex.z;

						normal = new THREE.Vector3( supershapeNormals[ k ], supershapeNormals[ k + 1 ], supershapeNormals[ k + 2 ] );
						normal.applyQuaternion( supershapesLine[ i ].quaternion );
						normals[ index + k ] = normal.x;
						normals[ index + k + 1 ] = normal.y;
						normals[ index + k + 2 ] = normal.z;
					}
					vertex = new THREE.Vector3( supershapePositions[ 0 ], supershapePositions[ 1 ], supershapePositions[ 2 ] );
					supershapesLine[ i ].localToWorld( vertex );
					positions[ index + supershapeSubdivision * 3 ] = vertex.x;
					positions[ index + supershapeSubdivision * 3 + 1 ] = vertex.y;
					positions[ index + supershapeSubdivision * 3 + 2 ] = vertex.z;
				}
				nautilus.geometry.attributes.position.needsUpdate = true;
				nautilus.geometry.attributes.normal.needsUpdate = true;
				nautilus.rotation.set( Math.PI, 0.0, 0.0 )
				if (debug)
					nautilusHelper.update();
			}

			function randomizeNautilus()
			{
				params.shapeRevolution = THREE.MathUtils.randInt( 1, 16 );
				randomizeSupershapes(0);
				randomizeSupershapes(1);
				updateSupershapes();
			}

			function setNautilusMesh()
			{
				let nautilusGeometry, nautilusMaterial;
				let texture;

				nautilusGeometry = new THREE.PlaneBufferGeometry( 2, 2, supershapeSubdivision, spiralSubdivision - 1 );
				texture = new THREE.TextureLoader().load( 'diffuse.jpg' );
				nautilusMaterial = new THREE.MeshStandardMaterial( { map: texture, side: THREE.DoubleSide } );
				nautilus = new THREE.Mesh( nautilusGeometry, nautilusMaterial );

				nautilus.castShadow = true; 
				nautilus.receiveShadow = true;
				nautilus.material.map.anisotropy = 16;
				scene.add( nautilus );

				if (debug)
				{
					nautilusHelper = new VertexNormalsHelper( nautilus, 0.1, 0x0000ff, 1 );
					scene.add( nautilusHelper );
				}
			}

			/*
			** Supershapes functions
			*/

			function setSupershapePositions( index, a, b, m, n1, n2, n3 )
			{
				let positions;
				let r, theta;
				let result1, result2;

				// Get supershape positions (cf. git)
				positions = supershapesLine[ index ].geometry.attributes.position.array;
				for ( let i = 0, j = 0; i < supershapeSubdivision; i ++ , j += 3 )
				{
					// Calculate the first part of the supershape equation
					theta = i * supershapeAngleStep;
					result1 = Math.cos( m / 4 * theta ) / a;
					result1 = Math.pow( Math.abs( result1 ), n2 );

					// Calculate the second part of the supershape equation
					result2 = Math.sin( m / 4 * theta ) / b;
					result2 = Math.pow( Math.abs( result2 ), n3 );

					// Find radius resolving the supershape equation
					r = Math.pow( result1 + result2, 1 / n1 );
					if ( Math.abs( r ) != 0 )
						r = 1 / r;						

					// Set current supershape line positions
					positions[ j ] = r * Math.cos( theta );
					positions[ j + 1 ] = r * Math.sin( theta );
					positions[ j + 2 ] = 0;
				}
				// Update supershape positions
				supershapesLine[ index ].geometry.attributes.position.needsUpdate = true;
			}

			function setSupershapeNormals( index )
			{
				let positions, normals;
				let indexPrev, indexNext;
				let position, positionPrev, positionNext;
				let directionPrev, directionNext;
				let normal;

				// Get supershape positions and normals (cf. git)
				positions = supershapesLine[ index ].geometry.attributes.position.array;
				normals = supershapesLine[ index ].geometry.attributes.normal.array;
				for ( let i = 0, j = 0; i < supershapeSubdivision; i ++, j += 3 )
				{
					// Set current, previous and next supershape segment index
					indexPrev = j - 3;
					if (i == 0)
						indexPrev = ( supershapeSubdivision - 1 ) * 3;
					indexNext = ( j + 3 ) % (supershapeSubdivision * 3 );

					// Get current, previous and next supershape segment position
					position = new THREE.Vector3( positions[ j ], positions[ j + 1 ], positions[ j + 2 ] );
					positionPrev = new THREE.Vector3( positions[ indexPrev ], positions[ indexPrev + 1 ], positions[ indexPrev + 2 ] );
					positionNext = new THREE.Vector3( positions[ indexNext ], positions[ indexNext + 1 ], positions[ indexNext + 2 ] );

					// Calculate current supershape segment normal
					directionPrev = positionPrev.clone().sub( position ).normalize();
					directionNext = position.clone().sub( positionNext ).normalize();
					normal = directionPrev.clone().add( directionNext ).normalize();

					// Set current supershape segment normals
					normals[ j ] = -normal.y;
					normals[ j + 1 ] = normal.x;
					normals[ j + 2 ] = normal.z;
				}
				// Update supershape normals
				supershapesLine[ index ].geometry.attributes.normal.needsUpdate = true;
			}

			function setSupershapesAttributes()
			{
				let revolutionAngle, normRevolution;
				let spiralPositions, spiralNormals, spiralAngle;
				let a, b, m, n1, n2, n3;

				revolutionAngle = Math.PI * 16.0 / params.shapeRevolution;
				// Get spiral positions and normals
				spiralPositions = spiralLine.geometry.attributes.position.array;
				spiralNormals = spiralLine.geometry.attributes.normal.array;
				for ( let i = 0, j = 0; i < spiralSubdivision; i ++, j += 3 )
				{
					// Set and lerp supershape variables from parameters
					normRevolution = i / spiralSubdivision * revolutionAngle;
					normRevolution = Math.abs( Math.sin( normRevolution ) );
					a = THREE.Math.lerp(params.shapeAA, params.shapeBA, normRevolution);
					b = THREE.Math.lerp(params.shapeAB, params.shapeBB, normRevolution);
					m = THREE.Math.lerp(params.shapeAM, params.shapeBM, normRevolution);
					n1 = THREE.Math.lerp(params.shapeAN1, params.shapeBN1, normRevolution);
					n2 = THREE.Math.lerp(params.shapeAN2, params.shapeBN2, normRevolution);
					n3 = THREE.Math.lerp(params.shapeAN3, params.shapeBN3, normRevolution);

					// Set supershape positions and normals
					setSupershapePositions( i, a, b, m, n1, n2, n3 );
					setSupershapeNormals( i );

					// Get current spiral segment normal angle
					spiralAngle = Math.atan( spiralNormals[ j + 1 ] / spiralNormals[ j ] );
					if (spiralNormals[ j ] < 0)
						spiralAngle += Math.PI;
		
					let scaleGoldenRatio = new THREE.Vector3( spiralPositions[ j ], spiralPositions[ j + 1 ], spiralPositions[ j + 2 ] ).distanceTo( new THREE.Vector3( ) );
					scaleGoldenRatio /= 1.618034;
					// Translate supershape at current spiral segment position, rotate it to match normal angle
					supershapesLine[ i ].scale.set( scaleGoldenRatio, scaleGoldenRatio, scaleGoldenRatio );
					supershapesLine[ i ].rotation.set( Math.PI / 2.0, spiralAngle, Math.PI );
					supershapesLine[ i ].position.set( spiralPositions[ j ], spiralPositions[ j + 1 ], spiralPositions[ j + 2 ] );
					if (debug)
						supershapesHelper[ i ].update();
				}
			}

			function randomizeSupershapes( i )
			{
				if ( i == 0 )
				{
					params.shapeAA = 1.0;
					params.shapeAB = 1.0;
					params.shapeAM = THREE.MathUtils.randInt( 0, 8 );
					params.shapeAN1 = THREE.MathUtils.randFloat( 0.0, 16.0 );
					params.shapeAN2 = THREE.MathUtils.randFloat( 0.0, 16.0 );
					params.shapeAN3 = THREE.MathUtils.randFloat( 0.0, 16.0 );
				}
				else if ( i == 1 )
				{
					params.shapeBA = 1.0;
					params.shapeBB = 1.0;
					params.shapeBM = THREE.MathUtils.randInt( 0, 8 );
					params.shapeBN1 = THREE.MathUtils.randFloat( 0.0, 16.0 );
					params.shapeBN2 = THREE.MathUtils.randFloat( 0.0, 16.0 );
					params.shapeBN3 = THREE.MathUtils.randFloat( 0.0, 16.0 );
				}
				return ;
			}

			function setSupershapesMesh()
			{
				let supershapePositions, supershapeNormals;
				let supershapeGeometry, supershapeMaterial;

				// Set supershape subdivision and ensure it does not exceed max subdivision
				supershapeSubdivision = 2 * Math.PI / supershapeAngleStep + 1;
				supershapeSubdivision = THREE.Math.clamp( supershapeSubdivision, 2, supershapeSubdivisionMax );
				for ( let i = 0; i < spiralSubdivision; i ++ )
				{
					// Create supershape buffer geometry, add positions and normals attributes
					supershapePositions = new Float32Array( supershapeSubdivision * 3 );
					supershapeNormals = new Float32Array( supershapeSubdivision * 3 );
					supershapeGeometry = new THREE.BufferGeometry();

					// Assign supershape positions and normals to geometry
					supershapeGeometry.setAttribute( 'position', new THREE.BufferAttribute( supershapePositions, 3 ) );
					supershapeGeometry.setAttribute( 'normal', new THREE.BufferAttribute( supershapeNormals, 3 ) );

					// Create supershape material, add supershape line object to the scene
					supershapeMaterial = new THREE.LineBasicMaterial( { color: 0x5050ff, linewidth: 2 } );
					supershapesLine.push( new THREE.Line( supershapeGeometry, supershapeMaterial ) );
					if (debug)
					{
						scene.add( supershapesLine[ i ] );
						// Create supershape helper, add it to the scene
						supershapesHelper.push(  new VertexNormalsHelper( supershapesLine[ i ], 0.2, 0xff0000, 1 ) );
						scene.add( supershapesHelper[ i ] );
					}
				}
			}

			function updateSupershapes()
			{
				setSupershapesAttributes();
				setNautilusAttributes();
			}

			/*
			** Spiral functions
			*/

			function setSpiralNormals( b )
			{
				let normals;
				let tangentAngle;
				let theta, phi;

				tangentAngle = Math.atan( 1.0 / b ) - Math.PI / 2.0;
				// Get spiral normals (cf. git)
				normals = spiralLine.geometry.attributes.normal.array;
				for ( let i = 0, j = 0; i < spiralSubdivision; i ++, j += 3 )
				{
					// Find trangent angle deriving the spiral equation
					theta = i * spiralAngleStep;
					phi = theta + tangentAngle;

					// Set current spiral normal
					normals[ j ] = Math.cos( phi );
					normals[ j + 1 ] = Math.sin( phi );
					normals[ j + 2 ] = 0;
				}
				// Update spiral normals
				spiralLine.geometry.attributes.normal.needsUpdate = true;
				if (debug)
					spiralHelper.update();
			}

			function setSpiralPositions( a, b )
			{
				let positions;
				let theta, r;

				// Get spiral positions (cf. git)
				positions = spiralLine.geometry.attributes.position.array;
				for ( let i = 0, j = 0; i < spiralSubdivision; i ++, j += 3 )
				{
					// Find radius resolving the spiral equation
					theta = i * spiralAngleStep;
					r = a * Math.pow( 2.718281, b * theta );

					// Set current spiral position
					positions[ j ] = r * Math.cos( theta );
					positions[ j + 1 ] = r * Math.sin( theta );
					positions[ j + 2 ] = 0;
				}
				// Update spiral positions
				spiralLine.geometry.attributes.position.needsUpdate = true;
			}

			function setSpiralAttributes()
			{
				let a, b;

				a = params.spiralA;
				b = params.spiralB;

				// Set spiral positions and normals
				setSpiralPositions( a, b );
				setSpiralNormals( b );
			}

			function updateSpiral()
			{
				setSpiralAttributes();
				setSupershapesAttributes();
				setNautilusAttributes();
			}

			function setSpiralMesh()
			{
				let spiralPositions, spiralNormals;
				let spiralGeometry, spiralMaterial;

				// Set spiral subdivision, ensure it does not exceed max subdivision
				spiralSubdivision = Math.PI * 8.0 / spiralAngleStep + 1;
				spiralSubdivision = THREE.Math.clamp( spiralSubdivision, 2, spiralSubdivisionMax );

				// Create spiral buffer geometry, add positions and normals attributes
				spiralPositions = new Float32Array( spiralSubdivision * 3 );
				spiralNormals = new Float32Array( spiralSubdivision * 3 );
				spiralGeometry = new THREE.BufferGeometry();

				// Assign spiral positions and normals to geometry
				spiralGeometry.setAttribute( 'position', new THREE.BufferAttribute( spiralPositions, 3 ) );
				spiralGeometry.setAttribute( 'normal', new THREE.BufferAttribute( spiralNormals, 3 ) );

				// Create spiral material, add spiral line object to the scene
				spiralMaterial = new THREE.LineBasicMaterial( { color: 0x5050ff, linewidth: 2 } );
				spiralLine = new THREE.Line( spiralGeometry, spiralMaterial );
				if (debug)
				{
					scene.add( spiralLine );
					// Create spiral normal helper, add it to the scene
					spiralHelper = new VertexNormalsHelper( spiralLine, 0.1, 0xff0000, 1 );
					scene.add( spiralHelper );
				}
			}

			/*
			** User interface function
			*/

			function createGUI()
			{
				let gui;
				let folderNautilus, folderSpiral, folderSupershapeA, folderSupershapeB;
				var randomize;
				
				gui = new GUI();
				// Set nautilus folder and parameters
				folderNautilus = gui.addFolder( 'Nautilus' );
				folderNautilus.add( params, 'shapeRevolution', 1, 16, 1. ).name( 'revolutions' ).listen().onChange( function () { updateSupershapes() } );
				randomize = { add:function(){ randomizeNautilus(); } };
				folderNautilus.add( randomize, 'add' ).name( 'randomize' );
				folderNautilus.open();
				
				// Set first supershape folder and parameters
				folderSupershapeA = gui.addFolder( 'Supershape A' );
				folderSupershapeA.add( params, 'shapeAA', 0.01, 1, .01 ).name( 'a' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAB', 0.01, 1, .01 ).name( 'b' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAM', 0, 8, 1. ).name( 'm' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAN1', 0, 16, .1 ).name( 'n1' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAN2', 0, 16, .1 ).name( 'n2' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAN3', 0, 16, .1 ).name( 'n3' ).listen().onChange( function () { updateSupershapes() } );
				randomize = { add:function(){ randomizeSupershapes(0); updateSupershapes(); } };
				folderSupershapeA.add( randomize, 'add' ).name( 'randomize' );
				folderSupershapeA.open();

				// Set second supershape folder and parameters
				folderSupershapeB = gui.addFolder( 'Supershape B' );
				folderSupershapeB.add( params, 'shapeBA', 0.01, 1, .01 ).name( 'a' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBB', 0.01, 1, .01 ).name( 'b' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBM', 0, 8, 1. ).name( 'm' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBN1', 0, 16, .1 ).name( 'n1' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBN2', 0, 16, .1 ).name( 'n2' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBN3', 0, 16, .1 ).name( 'n3' ).listen().onChange( function () { updateSupershapes() } );
				randomize = { add:function(){ randomizeSupershapes(1); updateSupershapes(); } };
				folderSupershapeB.add( randomize, 'add' ).name( 'randomize' );;
				folderSupershapeB.open();

				// Set spiral folder and parameters
				folderSpiral = gui.addFolder( 'Spiral' );
				folderSpiral.add( params, 'spiralA', 0, 8.0, .001 ).name( 'a' ).onChange( function () { updateSpiral() } );
				folderSpiral.add( params, 'spiralB', 0, 8.0, .001 ).name( 'b' ).onChange( function () { updateSpiral() } );
				folderSpiral.open();
			}

			/*
			** TODO
			*/

			function init()
			{
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.z = 500;

				controls = new OrbitControls( camera, container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x101010 );

				setSpiralMesh();
				setSpiralAttributes();

				setSupershapesMesh();
				setSupershapesAttributes();

				setNautilusMesh();
				setNautilusAttributes();

				hemiLight = new THREE.HemisphereLight( 0xffeeb1, 0x080820, 0.1 );
				scene.add(hemiLight);

				spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.position.set( -25.0, 50.0, 75.0 );
				spotLight.castShadow = true;

				spotLight.shadow.mapSize.width = 4096;
				spotLight.shadow.mapSize.height = 4096;
				spotLight.shadowBias = -0.001;
				scene.add( spotLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.shadowMapCullFace = THREE.CullFaceBack

				renderer.shadowCameraNear = 0.1;
				renderer.shadowCameraFar = 20000;
				renderer.shadowCameraFov = 45;

				stats = new Stats();
				container.appendChild( renderer.domElement );
				container.appendChild( stats.dom );

				createGUI();

				window.addEventListener( 'resize', onWindowResize, false );

				const helper = new THREE.CameraHelper( spotLight.shadow.camera );
				scene.add( helper );
			}

			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();	
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate()
			{
				stats.update();
				requestAnimationFrame( animate );
				controls.update();
				render();
			}

			function render()
			{
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>