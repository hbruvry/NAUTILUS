<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Nautilus</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script type="module">
			import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';
			import { MathUtils } from 'https://unpkg.com/three@0.121.1/build/three.module.js';
			import Stats from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/stats.module.js';
			import { GUI } from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/dat.gui.module.js';
			import { VertexNormalsHelper } from 'https://unpkg.com/three@0.121.1/examples/jsm/helpers/VertexNormalsHelper.js';
			import { EXRLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/EXRLoader.js';

			let container, stats;
			let camera, controls, scene, renderer;
			let debug = false;

			let spiralLine, spiralHelper;
			let spiralAngleStep = Math.PI / 120;
			let spiralSubdivision = 0;
			let spiralSubdivisionMax = 1024;

			let supershapesLine = [];
			let supershapesHelper = [];
			let supershapeAngleStep = Math.PI / 360;
			let supershapeSubdivision = 2;
			let supershapeSubdivisionMax = 1024;

			let nautilus, nautilusHelper;

			/*
			** TO CHECK
			*/

			let pngCubeRenderTarget, exrCubeRenderTarget;
			let pngBackground, exrBackground;

			//

			const params = {
				shapeRevolution: 6,
				shapeAA: 1,
				shapeAB: 1,
				shapeAM: 0,
				shapeAN1: 1,
				shapeAN2: 1,
				shapeAN3: 1,
				shapeBA: 1,
				shapeBB: 1,
				shapeBM: 0,
				shapeBN1: 1,
				shapeBN2: 1,
				shapeBN3: 1,
				spiralA: 1.0,
				spiralB: 0.128
			};

			init();
			animate();

			function setNautilusAttributes()
			{
				let positions, normals;

				positions = nautilus.geometry.attributes.position.array;
				normals = nautilus.geometry.attributes.normal.array;
				for ( let i = 0; i < spiralSubdivisionMax; i ++ )
				{
					let supershapePositions = supershapesLine[ i ].geometry.attributes.position.array;
					let supershapeNormals = supershapesLine[ i ].geometry.attributes.normal.array;
					for ( let j = 0; j < supershapeSubdivision; j ++ )
					{
						supershapesLine[ i ].updateMatrixWorld();
						let vertex = new THREE.Vector3( supershapePositions[ j * 3 ], supershapePositions[ j * 3 + 1 ], supershapePositions[ j * 3 + 2 ] );
						vertex.applyMatrix4( supershapesLine[ i ].matrixWorld );
						positions[ i * ( supershapeSubdivision + 1 ) * 3 + j * 3 ] = vertex.x;
						positions[ i * ( supershapeSubdivision + 1 ) * 3 + j * 3 + 1 ] = vertex.y;
						positions[ i * ( supershapeSubdivision + 1 ) * 3 + j * 3 + 2 ] = vertex.z;

						let normal = new THREE.Vector3( supershapeNormals[ j * 3 ], supershapeNormals[ j * 3 + 1 ], supershapeNormals[ j * 3 + 2 ] );
						normal.applyQuaternion( supershapesLine[ i ].quaternion );
						normals[ i * ( supershapeSubdivision + 1 ) * 3 + j * 3 ] = normal.x;
						normals[ i * ( supershapeSubdivision + 1 ) * 3 + j * 3 + 1 ] = normal.y;
						normals[ i * ( supershapeSubdivision + 1 ) * 3 + j * 3 + 2 ] = normal.z;
					}
					let vertex = new THREE.Vector3( supershapePositions[ 0 ], supershapePositions[ 1 ], supershapePositions[ 2 ] );
					supershapesLine[ i ].localToWorld( vertex );
					positions[ i * ( supershapeSubdivision + 1 ) * 3 + supershapeSubdivision * 3 ] = vertex.x;
					positions[ i * ( supershapeSubdivision + 1 ) * 3 + supershapeSubdivision * 3 + 1 ] = vertex.y;
					positions[ i * ( supershapeSubdivision + 1 ) * 3 + supershapeSubdivision * 3 + 2 ] = vertex.z;
				}
				nautilus.geometry.attributes.position.needsUpdate = true;
				nautilus.geometry.attributes.normal.needsUpdate = true;
				nautilus.rotation.set( Math.PI, 0.0, 3.0 * Math.PI / 2.0 )
				if (debug)
					nautilusHelper.update();
			}

			function randomizeNautilus()
			{
				params.shapeRevolution = THREE.MathUtils.randInt( 1, 16 );
				randomizeSupershapes(0);
				randomizeSupershapes(1);
				updateSupershapes();
			}

			function setNautilusMesh()
			{
				/*
				var r = "https://threejs.org/examples/textures/cube/Bridge2/";
				var urls = [ r + "posx.jpg", r + "negx.jpg",
										r + "posy.jpg", r + "negy.jpg",
										r + "posz.jpg", r + "negz.jpg" ];
										
				var textureCube = new THREE.CubeTextureLoader().load( urls );
				textureCube.format = THREE.RGBFormat;
				*/

				let nautilusGeometry = new THREE.CylinderBufferGeometry( 2, 2, 8, supershapeSubdivision, spiralSubdivisionMax - 1, true );
				// let nautilusMaterial = new THREE.MeshBasicMaterial( { color: 0xc0c0c0, side : THREE.DoubleSide/*, envMap: textureCube, combine: THREE.MixOperation, reflectivity: 0.5 */} );
				
				let nautilusMaterial = new THREE.MeshStandardMaterial( {
					color: 0xc0c0ff,
					metalness: 0.875,
					roughness: 0.125,
					envMapIntensity: 1.0,
					side : THREE.DoubleSide
				} );

				nautilus = new THREE.Mesh( nautilusGeometry, nautilusMaterial );
				nautilus.receiveShadow = true;
				nautilus.castShadow = true;
				scene.add( nautilus );
				if (debug)
				{
					nautilusHelper = new VertexNormalsHelper( nautilus, 0.1, 0x0000ff, 1 );
					scene.add( nautilusHelper );
				}
			}

			/*
			** Supershapes functions
			*/

			function setSupershapePositions( index, a, b, m, n1, n2, n3 )
			{
				let positions;
				let r, theta;
				let result1, result2;

				// Get supershape positions (cf. git)
				positions = supershapesLine[ index ].geometry.attributes.position.array;
				for ( let i = 0; i < supershapeSubdivision; i ++ )
				{
					// Calculate the first part of the supershape equation
					theta = i * supershapeAngleStep;
					result1 = Math.cos( m / 4 * theta ) / a;
					result1 = Math.pow(Math.abs( result1 ), n2);

					// Calculate the second part of the supershape equation
					result2 = Math.sin( m / 4 * theta ) / b;
					result2 = Math.pow( Math.abs( result2 ), n3);

					// Find radius resolving the supershape equation
					r = Math.pow( result1 + result2, 1 / n1 );
					if ( Math.abs(r) != 0 )
						r = 1/ r;						

					// Set current supershape line positions
					positions[ i * 3 ] = r * Math.cos( theta );
					positions[ i * 3 + 1 ] = r * Math.sin( theta );
					positions[ i * 3 + 2 ] = 0;
				}
				// Update supershape positions
				supershapesLine[ index ].geometry.attributes.position.needsUpdate = true;
			}

			function setSupershapeNormals( index )
			{
				let positions, normals;
				let indexCurrent, indexPrev, indexNext;
				let position, positionPrev, positionNext;
				let directionPrev, directionNext;
				let normal;

				// Get supershape positions and normals (cf. git)
				positions = supershapesLine[ index ].geometry.attributes.position.array;
				normals = supershapesLine[ index ].geometry.attributes.normal.array;
				for ( let i = 0; i < supershapeSubdivision; i ++ )
				{
					// Set current, previous and next supershape segment index
					indexCurrent = i * 3;
					indexPrev = ( i - 1 ) * 3;
					if (i == 0)
						indexPrev = ( supershapeSubdivision - 1 ) * 3;
					indexNext = ( ( i + 1 ) % supershapeSubdivision ) * 3;

					// Get current, previous and next supershape segment position
					position = new THREE.Vector3( positions[ indexCurrent ], positions[ indexCurrent + 1 ], positions[ indexCurrent + 2] );
					positionPrev = new THREE.Vector3( positions[ indexPrev ], positions[ indexPrev + 1 ], positions[ indexPrev + 2] );
					positionNext = new THREE.Vector3( positions[ indexNext ], positions[ indexNext + 1 ], positions[ indexNext + 2] );

					// Calculate current supershape segment normal
					directionPrev = positionPrev.clone().sub( position ).normalize();
					directionNext = position.clone().sub( positionNext ).normalize();
					normal = directionPrev.clone().add( directionNext ).normalize();

					// Set current supershape segment normals
					normals[ i * 3 ] = -normal.y;
					normals[ i * 3 + 1 ] = normal.x;
					normals[ i * 3 + 2 ] = normal.z;
				}
				// Update supershape normals
				supershapesLine[ index ].geometry.attributes.normal.needsUpdate = true;
			}

			function setSupershapesAttributes()
			{
				let revolutionAngle, normRevolution;
				let spiralPositions, spiralNormals, spiralAngle;
				let a, b, m, n1, n2, n3;

				revolutionAngle = Math.PI * 16.0 / params.shapeRevolution;
				// Get spiral positions and normals
				spiralPositions = spiralLine.geometry.attributes.position.array;
				spiralNormals = spiralLine.geometry.attributes.normal.array;
				for ( let i = 0; i < spiralSubdivisionMax; i ++ )
				{
					// Set and lerp supershape variables from parameters
					normRevolution = i / spiralSubdivision * revolutionAngle;
					normRevolution = Math.abs( Math.sin( normRevolution ) );
					a = THREE.Math.lerp(params.shapeAA, params.shapeBA, normRevolution);
					b = THREE.Math.lerp(params.shapeAB, params.shapeBB, normRevolution);
					m = THREE.Math.lerp(params.shapeAM, params.shapeBM, normRevolution);
					n1 = THREE.Math.lerp(params.shapeAN1, params.shapeBN1, normRevolution);
					n2 = THREE.Math.lerp(params.shapeAN2, params.shapeBN2, normRevolution);
					n3 = THREE.Math.lerp(params.shapeAN3, params.shapeBN3, normRevolution);

					// Set supershape positions and normals
					setSupershapePositions( i, a, b, m, n1, n2, n3 );
					setSupershapeNormals( i );

					// Get current spiral segment normal angle
					spiralAngle = Math.atan( spiralNormals[ i * 3 + 1 ] / spiralNormals[ i * 3 ] );
					if (spiralNormals[ i * 3 ] < 0)
						spiralAngle += Math.PI;
		
					let scaleGoldenRatio = new THREE.Vector3( spiralPositions[ i * 3 ], spiralPositions[ i * 3 + 1 ], spiralPositions[ i * 3 + 2 ] ).distanceTo( new THREE.Vector3( ) );
					scaleGoldenRatio = scaleGoldenRatio / 1.618034;
					// Translate supershape at current spiral segment position, rotate it to match normal angle
					supershapesLine[ i ].scale.set( scaleGoldenRatio, scaleGoldenRatio, scaleGoldenRatio );
					supershapesLine[ i ].rotation.set( Math.PI / 2, spiralAngle, 0 );
					supershapesLine[ i ].position.set( spiralPositions[ i * 3 ], spiralPositions[ i * 3 + 1 ], spiralPositions[ i * 3 + 2 ] );
					if (debug)
						supershapesHelper[ i ].update();
				}
			}

			function randomizeSupershapes( i )
			{
				if ( i == 0 )
				{
					params.shapeAA = 1.0;
					params.shapeAB = 1.0;
					params.shapeAM = THREE.MathUtils.randInt( 0, 8 );
					params.shapeAN1 = THREE.MathUtils.randFloat( 0.0, 16.0 );
					params.shapeAN2 = THREE.MathUtils.randFloat( 0.0, 16.0 );
					params.shapeAN3 = THREE.MathUtils.randFloat( 0.0, 16.0 );
				}
				else if ( i == 1 )
				{
					params.shapeBA = 1.0;
					params.shapeBB = 1.0;
					params.shapeBM = THREE.MathUtils.randInt( 0, 8 );
					params.shapeBN1 = THREE.MathUtils.randFloat( 0.0, 16.0 );
					params.shapeBN2 = THREE.MathUtils.randFloat( 0.0, 16.0 );
					params.shapeBN3 = THREE.MathUtils.randFloat( 0.0, 16.0 );
				}
				return ;
			}

			function setSupershapesMesh()
			{
				let supershapePositions, supershapeNormals;
				let supershapeGeometry, supershapeMaterial;

				// Set supershape subdivision and ensure it does not exceed max subdivision
				supershapeSubdivision = 2 * Math.PI / supershapeAngleStep + 1;
				supershapeSubdivision = THREE.Math.clamp( supershapeSubdivision, 2, supershapeSubdivisionMax );
				for ( let i = 0; i < spiralSubdivisionMax; i ++ )
				{
					// Create supershape buffer geometry, add positions and normals attributes
					supershapePositions = new Float32Array( supershapeSubdivision * 3 );
					supershapeNormals = new Float32Array( supershapeSubdivision * 3 );
					supershapeGeometry = new THREE.BufferGeometry();

					// Assign supershape positions and normals to geometry
					supershapeGeometry.setAttribute( 'position', new THREE.BufferAttribute( supershapePositions, 3 ) );
					supershapeGeometry.setAttribute( 'normal', new THREE.BufferAttribute( supershapeNormals, 3 ) );

					// Create supershape material, add supershape line object to the scene
					supershapeMaterial = new THREE.LineBasicMaterial( { color: 0x5050ff, linewidth: 2 } );
					supershapesLine.push( new THREE.Line( supershapeGeometry, supershapeMaterial ) );
					if (debug)
					{
						scene.add( supershapesLine[ i ] );
						// Create supershape helper, add it to the scene
						supershapesHelper.push(  new VertexNormalsHelper( supershapesLine[ i ], 0.2, 0xff0000, 1 ) );
						scene.add( supershapesHelper[ i ] );
					}
				}
			}

			function updateSupershapes()
			{
				setSupershapesAttributes();
				setNautilusAttributes();
			}

			/*
			** Spiral functions
			*/

			function setSpiralNormals( b )
			{
				let normals;
				let theta, phi;

				// Get spiral normals (cf. git)
				normals = spiralLine.geometry.attributes.normal.array;
				for ( let i = 0; i < spiralSubdivision; i ++ )
				{
					// Find trangent angle deriving the spiral equation
					theta = i * spiralAngleStep;
					phi = theta + Math.atan( 1.0 / b ) - Math.PI / 2.0;

					// Set current spiral normal
					normals[ i * 3 ] = Math.cos( phi );
					normals[ i * 3 + 1 ] = Math.sin( phi );
					normals[ i * 3 + 2 ] = 0;
				}
				// Update spiral normals
				spiralLine.geometry.attributes.normal.needsUpdate = true;
				if (debug)
					spiralHelper.update();
			}

			function setSpiralPositions( a, b )
			{
				let positions;
				let theta, r;

				// Get spiral positions (cf. git)
				positions = spiralLine.geometry.attributes.position.array;
				for ( let i = 0; i < spiralSubdivision; i ++ )
				{
					// Find radius resolving the spiral equation
					theta = i * spiralAngleStep;
					r = a * Math.pow( 2.718281, b * theta );

					// Set current spiral position
					positions[ i * 3 ] = r * Math.cos( theta );
					positions[ i * 3 + 1 ] = r * Math.sin( theta );
					positions[ i * 3 + 2 ] = 0;
				}
				// Update spiral positions
				spiralLine.geometry.attributes.position.needsUpdate = true;
			}

			function setSpiralAttributes()
			{
				let a, b;

				a = params.spiralA;
				b = params.spiralB;

				// Set spiral positions and normals
				setSpiralPositions( a, b );
				setSpiralNormals( b );
			}

			function updateSpiral()
			{
				setSpiralAttributes();
				setSupershapesAttributes();
				setNautilusAttributes();
			}

			function setSpiralMesh()
			{
				let spiralPositions, spiralNormals;
				let spiralGeometry, spiralMaterial;

				// Set spiral subdivision, ensure it does not exceed max subdivision
				spiralSubdivision = Math.PI * 16.0 / spiralAngleStep + 1;
				spiralSubdivision = THREE.Math.clamp( spiralSubdivision, 2, spiralSubdivisionMax );

				// Create spiral buffer geometry, add positions and normals attributes
				spiralPositions = new Float32Array( spiralSubdivision * 3 );
				spiralNormals = new Float32Array( spiralSubdivision * 3 );
				spiralGeometry = new THREE.BufferGeometry();

				// Assign spiral positions and normals to geometry
				spiralGeometry.setAttribute( 'position', new THREE.BufferAttribute( spiralPositions, 3 ) );
				spiralGeometry.setAttribute( 'normal', new THREE.BufferAttribute( spiralNormals, 3 ) );

				// Create spiral material, add spiral line object to the scene
				spiralMaterial = new THREE.LineBasicMaterial( { color: 0x5050ff, linewidth: 2 } );
				spiralLine = new THREE.Line( spiralGeometry, spiralMaterial );
				if (debug)
				{
					scene.add( spiralLine );
					// Create spiral normal helper, add it to the scene
					spiralHelper = new VertexNormalsHelper( spiralLine, 0.1, 0xff0000, 1 );
					scene.add( spiralHelper );
				}
			}

			/*
			** User interface function
			*/

			function createGUI()
			{
				let gui;
				let folderNautilus, folderSpiral, folderSupershapeA, folderSupershapeB;
				var randomize;
				
				gui = new GUI();
				// Set nautilus folder and parameters
				folderNautilus = gui.addFolder( 'Nautilus' );
				folderNautilus.add( params, 'shapeRevolution', 1, 16, 1. ).name( 'revolutions' ).listen().onChange( function () { updateSupershapes() } );
				randomize = { add:function(){ randomizeNautilus(); } };
				folderNautilus.add( randomize, 'add' ).name( 'randomize' );
				folderNautilus.open();
				
				// Set first supershape folder and parameters
				folderSupershapeA = gui.addFolder( 'Supershape A' );
				folderSupershapeA.add( params, 'shapeAA', 0.01, 1, .01 ).name( 'a' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAB', 0.01, 1, .01 ).name( 'b' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAM', 0, 8, 1. ).name( 'm' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAN1', 0, 16, .1 ).name( 'n1' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAN2', 0, 16, .1 ).name( 'n2' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeA.add( params, 'shapeAN3', 0, 16, .1 ).name( 'n3' ).listen().onChange( function () { updateSupershapes() } );
				randomize = { add:function(){ randomizeSupershapes(0); updateSupershapes(); } };
				folderSupershapeA.add( randomize, 'add' ).name( 'randomize' );
				folderSupershapeA.open();

				// Set second supershape folder and parameters
				folderSupershapeB = gui.addFolder( 'Supershape B' );
				folderSupershapeB.add( params, 'shapeBA', 0.01, 1, .01 ).name( 'a' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBB', 0.01, 1, .01 ).name( 'b' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBM', 0, 8, 1. ).name( 'm' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBN1', 0, 16, .1 ).name( 'n1' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBN2', 0, 16, .1 ).name( 'n2' ).listen().onChange( function () { updateSupershapes() } );
				folderSupershapeB.add( params, 'shapeBN3', 0, 16, .1 ).name( 'n3' ).listen().onChange( function () { updateSupershapes() } );
				randomize = { add:function(){ randomizeSupershapes(1); updateSupershapes(); } };
				folderSupershapeB.add( randomize, 'add' ).name( 'randomize' );;
				folderSupershapeB.open();

				// Set spiral folder and parameters
				folderSpiral = gui.addFolder( 'Spiral' );
				folderSpiral.add( params, 'spiralA', 0, 8.0, .001 ).name( 'a' ).onChange( function () { updateSpiral() } );
				folderSpiral.add( params, 'spiralB', 0, 8.0, .001 ).name( 'b' ).onChange( function () { updateSpiral() } );
				folderSpiral.open();
			}

			/*
			** TODO
			*/

			function init()
			{
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 4000 );
				camera.position.z = 200;

				controls = new OrbitControls( camera, container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf8f8ff );

				const spotLight = new THREE.SpotLight();
				spotLight.angle = Math.PI / 16;
				spotLight.penumbra = 0.5;
				spotLight.castShadow = true;
				spotLight.position.set( - 1000, 1000, 1000 );
				scene.add( spotLight );


				setSpiralMesh();
				setSpiralAttributes();

				setSupershapesMesh();
				setSupershapesAttributes();

				setNautilusMesh();
				setNautilusAttributes();

				/*
				** TO CHECK
				*/

				THREE.DefaultLoadingManager.onLoad = function ( ) { pmremGenerator.dispose(); };

				new EXRLoader()
					.setDataType( THREE.UnsignedByteType )
					.load( 'https://threejs.org/examples/textures/piz_compressed.exr', function ( texture ) {
						exrCubeRenderTarget = pmremGenerator.fromEquirectangular( texture );
						exrBackground = exrCubeRenderTarget.texture;
						texture.dispose();
					} );

				new THREE.TextureLoader().load( 'https://threejs.org/examples/textures/equirectangular.png', function ( texture ) {					texture.encoding = THREE.sRGBEncoding;
					pngCubeRenderTarget = pmremGenerator.fromEquirectangular( texture );
					pngBackground = pngCubeRenderTarget.texture;
					texture.dispose();
				} );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );

				/*
				** TO CHECK
				*/

				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();

				//

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				stats = new Stats();
				container.appendChild( renderer.domElement );
				container.appendChild( stats.dom );

				/*
				** TO CHECK
				*/

				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.outputEncoding = THREE.sRGBEncoding;

				//

				createGUI();

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();	
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate()
			{
				stats.update();
				requestAnimationFrame( animate );
				controls.update();
				render();
			}

			function render()
			{
				/*
				** TO CHECK
				*/

				let newEnvMap = nautilus.material.envMap;
				let background = scene.background;

				newEnvMap = exrCubeRenderTarget ? exrCubeRenderTarget.texture : null;
				background = exrBackground;
				nautilus.material.envMap = newEnvMap;
				nautilus.material.needsUpdate = true;

				scene.background = background;
				renderer.toneMappingExposure = 0.5;

				//

				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>